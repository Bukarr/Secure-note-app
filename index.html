<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vaultlify ‚Äì Secure Note App</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
  <!-- Mammoth.js for .docx -->
<script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>

<!-- PDF.js for .pdf -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>

  <style>
    body.dark-mode { background-color: #121212; color: #f1f1f1; }
    .note-card { margin-bottom: 1rem; }
    #drop-zone { border: 2px dashed #ccc; padding: 20px; text-align: center; margin-bottom: 1rem; }
  </style>
</head>
<body class="bg-light">
<div class="container py-4">
  <h2 class="text-center mb-3">üîê Vaultlify</h2>

  <!-- Password Unlock -->
  <div class="mb-3">
    <input type="password" id="passwordInput" class="form-control" placeholder="Enter password to unlock notes" />
    <button class="btn btn-dark mt-2" onclick="unlockNotes()">Unlock</button>
  </div>

  <!-- Folder & Tag Management -->
  <div class="mb-3">
    <select id="folderSelect" class="form-select" onchange="renderNotes()"> <option value="">All Folders</option> </select>
    <input type="text" id="newFolderInput" class="form-control mt-2" placeholder="Create new folder" />
    <button class="btn btn-outline-primary mt-2" onclick="createFolderBtn()">Add Folder</button>
  </div>

  <!-- Note Input -->
  <div class="mb-3">
    <textarea id="noteInput" class="form-control" rows="3" placeholder="Write your note..."></textarea>
    <input type="text" id="tagInput" class="form-control mt-2" placeholder="Tags (comma separated)" />
    <input type="date" id="dateInput" class="form-control mt-2" />
    <div class="mt-2 d-flex gap-2 flex-wrap">
      <button class="btn btn-primary" onclick="saveNote()">Save Note</button>
      <button class="btn btn-info" onclick="startSpeechToText()">üé§ Voice Note</button>
      <!-- OCR Upload Button -->
      <button class="btn btn-warning" onclick="triggerFileInput()">Scan Image</button>
      <button class="btn btn-secondary" onclick="toggleDarkMode()">üåì Toggle Theme</button>
      
<!-- Hidden File Input -->
<input type="file" id="imageInput" accept="image/*" style="display:none" onchange="handleImageUpload(this)" />
    </div>
  </div>

  <!-- Search & Import/Export -->
  <div class="mb-3 d-flex gap-2 flex-wrap">
    <input type="text" id="searchInput" class="form-control" placeholder="Search notes..." oninput="searchNotes()" />
    <button class="btn btn-outline-success" onclick="exportAllNotes()">Export All</button>
    <input type="file" id="importInput" accept=".json" style="display:none" onchange="importNotes(this)" />
    <button class="btn btn-outline-secondary" onclick="document.getElementById('importInput').click()">Import Notes</button>
  </div>

  <!-- Drag & Drop OCR -->
  <div id="drop-zone" ondrop="handleDrop(event)" ondragover="event.preventDefault()">Drag & Drop an image here to scan text</div>

  <!-- Notes Display -->
  <div id="notesContainer"></div>
</div>

<!-- Modular Scripts -->
<script src="notes.js"></script>
<script src="ui.js"></script>
<script src="ocr.js"></script>
<script src="search.js"></script>
<script src="theme.js"></script>
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/service-worker.js')
      .then(() => console.log('Service Worker registered'))
      .catch(err => console.error('SW registration failed:', err));
  }
</script>
<script>
  function getSelectedNotes() {
  const selectedIds = Array.from(document.querySelectorAll('.note-select:checked'))
    .map(cb => cb.value);

  return notes.filter(note => selectedIds.includes(note.id.toString()));
}

function exportSelectedNotes() {
  const format = prompt("Choose export format: pdf, txt, doc, docx").toLowerCase();
  if (!['pdf', 'txt', 'doc', 'docx'].includes(format)) {
    alert("Unsupported format. Please choose pdf, txt, doc, or docx.");
    return;
  }

  const selectedNotes = getSelectedNotes();
  if (selectedNotes.length === 0) {
    alert("No notes selected.");
    return;
  }

  if (format === 'pdf') {
    exportAsPDF(selectedNotes);
  } else {
    exportAsText(selectedNotes, format);
  }
}

function formatNoteForExport(note, index = null) {
  const title = index !== null ? `Note ${index + 1}` : `Note`;
  const divider = '========================================';

  return `
${title}
${divider}
Text:
${note.text.trim()}

Tags: ${note.tags.join(', ')}
Folder: ${note.folder}
Date: ${new Date(note.date).toLocaleDateString()}

${divider}\n`;
}

function exportAsPDF(selectedNotes) {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  let y = 10;

  selectedNotes.forEach((note, i) => {
    const content = formatNoteForExport(note, i);
    const lines = doc.splitTextToSize(content, 180);
    doc.text(lines, 10, y);
    y += lines.length * 7;

    if (y > 270 && i < selectedNotes.length - 1) {
      doc.addPage();
      y = 10;
    }
  });

  doc.save('selected_notes.pdf');
}

function exportAsText(selectedNotes, format) {
  const content = selectedNotes.map((note, i) => formatNoteForExport(note, i)).join('\n');
  let mimeType = 'text/plain';

  if (format === 'doc' || format === 'docx') {
    mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
  }

  const blob = new Blob([content], { type: mimeType });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = `selected_notes.${format}`;
  link.click();
  URL.revokeObjectURL(link.href);
}

</script>
<script>
function exportNote(id, format) {
  const note = notes.find(n => n.id === id);
  if (!note) return alert('Note not found.');

  const title = `Note_${note.id}`;
  const header = `Title: ${title}\nDate: ${new Date(note.date).toLocaleDateString()}\nFolder: ${note.folder}\nTags: ${note.tags.join(', ')}\n\n========================================\n`;
  const footer = `\n========================================\nExported on: ${new Date().toLocaleString()}`;
  const fullContent = `${header}${note.text}${footer}`;

  if (format === 'pdf') {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();

    // Layout settings
    const pageWidth = doc.internal.pageSize.width;
    const pageHeight = doc.internal.pageSize.height;
    const marginLeft = 20;
    const marginTop = 20;
    const marginBottom = 20;
    const lineHeight = 7; // More compact spacing
    const titleFontSize = 16;
    const bodyFontSize = 12;
    const footerFontSize = 10;
    const maxLinesPerPage = Math.floor((pageHeight - marginTop - marginBottom - 30) / lineHeight);

    const lines = doc.splitTextToSize(fullContent, pageWidth - marginLeft * 2);
    let currentLine = 0;
    let pageNum = 1;

    while (currentLine < lines.length) {
      if (pageNum > 1) doc.addPage();

      // Title styling
      doc.setFont('helvetica', 'bold');
      doc.setFontSize(titleFontSize);
      doc.text(`Note Export: ${title}`, marginLeft, marginTop);

      // Body styling
      doc.setFont('times', 'normal');
      doc.setFontSize(bodyFontSize);
      const pageLines = lines.slice(currentLine, currentLine + maxLinesPerPage);
      doc.text(pageLines, marginLeft, marginTop + 10);

      // Footer with page number
      doc.setFont('courier', 'italic');
      doc.setFontSize(footerFontSize);
      doc.text(`Page ${pageNum}`, pageWidth - marginLeft, pageHeight - 10, { align: 'right' });

      currentLine += maxLinesPerPage;
      pageNum++;
    }

    doc.save(`${title}.pdf`);
  } else {
    let mimeType = 'text/plain';
    if (format === 'doc' || format === 'docx') {
      mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
    }

    const blob = new Blob([fullContent], { type: mimeType });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${title}.${format}`;
    link.click();
    URL.revokeObjectURL(link.href);
  }
}

</script>
<script>
  import jsPDF from "jspdf";

export const exportNotesToPDF = (notes) => {
  const doc = new jsPDF();

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 25;
  const usableWidth = pageWidth - margin * 2;
  const fontSize = 12;
  const lineHeight = 10;

  doc.setFontSize(fontSize);

  let pageCount = 1;

  notes.forEach((note, index) => {
    const title = `Note ${index + 1}`;
    const content = note.content || "";

    const lines = doc.splitTextToSize(content, usableWidth);
    let cursorY = margin;
    let lineIndex = 0;

    while (lineIndex < lines.length) {
      doc.setFont(undefined, "bold");
      doc.text(title, margin, cursorY);
      cursorY += lineHeight;

      doc.setFont(undefined, "normal");

      while (
        lineIndex < lines.length &&
        cursorY + lineHeight <= pageHeight - margin - lineHeight // reserve space for footer
      ) {
        doc.text(lines[lineIndex], margin, cursorY);
        cursorY += lineHeight;
        lineIndex++;
      }

      // Footer: Page number
      doc.setFontSize(10);
      doc.setFont(undefined, "italic");
      doc.text(`Page ${pageCount}`, pageWidth / 2, pageHeight - margin / 2, {
        align: "center",
      });

      pageCount++;

      // If more lines remain, add a new page
      if (lineIndex < lines.length) {
        doc.addPage();
        doc.setFontSize(fontSize);
        cursorY = margin;
      }
    }

    // Add a new page for the next note if not at the end
    if (index < notes.length - 1) {
      doc.addPage();
      doc.setFontSize(fontSize);
    }
  });

  doc.save("My_Notes.pdf");
};

</script>
<script>
function importNotes(input) {
  const file = input.files[0];
  if (!file) return;

  const reader = new FileReader();
  const noteInput = document.getElementById('noteInput');

  const ext = file.name.split('.').pop().toLowerCase();

  if (ext === 'txt') {
    reader.onload = function (e) {
      noteInput.value = e.target.result;
    };
    reader.readAsText(file);
  }

  else if (ext === 'docx') {
    reader.onload = function (e) {
      mammoth.extractRawText({ arrayBuffer: e.target.result })
        .then(result => {
          noteInput.value = result.value;
        })
        .catch(err => {
          alert("Error reading DOCX file.");
          console.error(err);
        });
    };
    reader.readAsArrayBuffer(file);
  }

  else if (ext === 'pdf') {
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    reader.onload = function (e) {
      const typedArray = new Uint8Array(e.target.result);
      pdfjsLib.getDocument(typedArray).promise.then(pdf => {
        let textContent = '';
        const maxPages = pdf.numPages;
        const pagePromises = [];

        for (let i = 1; i <= maxPages; i++) {
          pagePromises.push(
            pdf.getPage(i).then(page => page.getTextContent())
              .then(content => {
                const strings = content.items.map(item => item.str);
                textContent += strings.join(' ') + '\n\n';
              })
          );
        }

        Promise.all(pagePromises).then(() => {
          noteInput.value = textContent;
        });
      }).catch(err => {
        alert("Error reading PDF file.");
        console.error(err);
      });
    };
    reader.readAsArrayBuffer(file);
  }

  else if (ext === 'doc') {
    alert("DOC format is not natively supported in browsers. Please convert to DOCX or TXT.");
  }

  else {
    alert("Unsupported file type. Please upload a .txt, .docx, or .pdf file.");
  }
}
</script>
<script>
  async function scanImageWithOCRSpace(file) {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('apikey', 'K83174371688957'); // üîê Replace with your actual key
    formData.append('language', 'eng'); // üåê Change to other languages if needed
    formData.append('isOverlayRequired', 'false'); // üñºÔ∏è Bounding boxes not needed
    formData.append('isHandwriting', 'true'); // ‚úçÔ∏è Enables handwriting recognition
    formData.append('detectOrientation', 'true'); // üîÑ Auto-rotate if needed
    formData.append('scale', 'true'); // ‚úÇÔ∏è Auto-crop and scale image

    try {
      const response = await fetch('https://api.ocr.space/parse/image', {
        method: 'POST',
        body: formData
      });

      const result = await response.json();

      const parsedText = result?.ParsedResults?.[0]?.ParsedText?.trim();
      const fallbackMessage = '‚ö†Ô∏è No readable text was found in the image. Try a clearer photo or better lighting.';

      document.getElementById('noteInput').value = parsedText || fallbackMessage;
    } catch (err) {
      console.error('OCR.space error:', err);
      alert('‚ùå Failed to scan image. Please try again.');
    }
  }

  function handleImageUpload(input) {
    const file = input.files[0];
    if (file) {
      scanImageWithOCRSpace(file);
    }
  }

  function triggerFileInput() {
    document.getElementById('imageInput').click();
  }
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="export.js"></script>
</body>
</html>
